[Following are some notes by Karel Suhajda on version 0.5 of WLS.]

------------

I've been playing [WLS] and I think I have found a method how to make it 
faster. The method (almost) doesn't depend on any pre-set searching order 
and it tries to select cells which will have the greatest impact on its 
surroundings (i.e. setting this cell will force setting of another cells). 
The cell selection method is quite slow but it cuts the tree significantly 
and the algorithm is capable to test all possibilities sooner than the 
original algorithm (100 times slower but requiring less than 100 times 
less attempts).

I've also enhanced the GUI user-friendliness, removed a few bugs
from the program and enabled some half-implemented features.

------------

Here is an incomplete list of what I've changed:

- save is possible when not searching
  (it starts a search, saves and resets the search)
  or when search is in progress
  (pauses, saves, continues)

- added accelerators:
  left/right arrows and PgUp/PgDn change generations
  Ctrl+O - load
  Ctrl+S - save

- added menu item:
  Edit/Copy result to definition
  - usable when partial result is found (using 'X' cells) to extend
the search   by editing and continuing from the result point

- Options/output settings:
  - Stop when an object is found now works
  - Dump to file every X calculations doesn't display a message
    so it doesn't stop the search

- Options/search settings
  - added First try volatile cells (called 'smart' inside the code)
    THIS IS IT! :-)
  - removed Fast symmetry (sigh)
    explanation: I had a great trouble with the fast symmetry so I
removed it     and speeded up the non-fast symmetry process. Now
maybe Fast symmetry can     go in again when my problems are solved
but I don't see the point

- when paused, current search status and number of attempts is
displayed

- program
  - many bugs removed
  - many bugs added (unintentionally, of course :-)
  - huge changes to code, variables, structures 
    and some even to the dump file format
  - few or no comments on where I changed something

  - initsearchorder removed from initcells and used after the cells
are loaded. It makes use of the field contents now. Made possible to
remove some redundant checks from the cell selection routines.   -
many new fields in the CELL structure, some old fields removed
  - completely rewritten setcell() and backup()
  - new function rescell() (opposite to setcell)
  - changed handling of looped cells (frozen and symmetric): all are
set at once     by setcell/rescell and only those not mirrored are
added to stack - works like Fast symmetry while keeping the field
fully updated.   - removed one of many procedures handling
symmetries (in initsearchorder)   - changed behaviour of unchecked
('X') cells a few times. Now, 'X' cell can     be set to ON or OFF
if the rules require it. No excludecone() !! - only the     initial
X cells are not checked.
  - new search method beginning at getsmartunknown() and
smartpropagate()   
I've tested it on some quite small search - a search for p4 MW
emulator in a Y-symmetric 7x15 field. Standard method with default
settings requires 80 seconds to find it, with the best settings (all
gens first + search for wide) it requires about 7 seconds to find it
and another two minutes to make sure it is the only one. The 'smart'
method finds it in 5 seconds and spends another 15 seconds on
searching all the remaining possibilities (only 60.000 attempts :-)

On larger grids, however, the method seems still to be pretty slow. ...

------------

I've reached some linear speedup (about 60%) by:

 - repairing a harmless yet time consuming bug in my code (I just wonder why
it didn't produce an endless loop)
 - reorganising trans and implic tables to just one table with easier
manipulation

I've also changed ON, OFF and UNK values (!!!) but I think I've killed all
problems caused by it. It was necessary for getting the new implic table to
reasonable bounds. I also found UNK value of 0 better because the cell state
is often checked for it. Current values are:

ON = 1
OFF = 9
UNK = 0

The descriptor is calculated as (sum of neighbors)*10 + (cell state)*3 +
(future cell state). This makes a descriptor in range about (0, 766) and
involves all ten cell states so any other cell state checking is not
necessary. Look at consistify() - it's a lot more straightforward now.

------------

I've implemented a window and a threshold to the 'max impact' method: taken
from the first unknown cell in the search order, maximum of <window> cells
is examined (including known cells which are skipped but counted). If the
<threshold> value is exceeded, the examination is stopped and the cell is
selected as the best candidate. This way, the search doesn't go too far away
from the predefined search order and the search actually is somewhat faster.
It appears mostly on longer searches....

In the search settings window, statistical values are shown containing an
average of the last 100k attempts which helps you to set better values for
further search.

I've changed the dump file format. There were too many unnecessary things.
Now, only the parameters, the rules, the original field and the stack
(without direct implications from the original field) is exported.

------------

[Why does it seem to prefer setting ON cells?]

The 'impact' algorithm counts the number of cells changed if the particular
cell is set to ON and another number if the cell is set to OFF. The best
choice is where the sum of the two numbers is the greatest - but the first
examined state is selected based on whether more cells are affected by
selecting ON or OFF. This way the shorter tree is examined first. ... 
You can mask it manually in the source code - in search.c, change the line
[1083]
                smartchoice = (bestlen1 > bestlen0) ? ON : OFF;
to
                smartchoice = UNK;


